- #SQL마스터클래스
	- 14.1 Functions
		- ```sql
		  CREATE OR REPLACE FUNCTION hello_world (user_name text)
		  RETURNS text AS
		  $$
		  SELECT 'hello ' || user_name;
		  $$
		  LANGUAGE SQL;
		  SELECT title, hello_world() FROM movies;
		  
		  CREATE OR REPLACE FUNCTION hello_world (text, text)
		  RETURNS text AS
		  $$
		  SELECT 'hello ' || $1 || ' and ' || $2;
		  $$
		  LANGUAGE SQL;
		  SELECT title, hello_world() FROM movies;
		  ```
	- 14.2 Return Types
		- 셀이 아닌 레코드를 함수의 인자로 설정할 수 있다.
		- ```sql
		  CREATE OR REPLACE FUNCTION is_hit_or_flop (movie movies)
		  RETURNS TEXT AS
		  $$
		    SELECT CASE
		      WHEN moyie. revenue > movie.budget THEN 'Hit'
		      WHEN movie. revenue ‹ movie.budget THEN 'Flop'
		      ELSE 'N/A'
		    END
		  $$
		  LANGUAGE SQL;
		  SELECT
		  	title,
		      is_hit_or_flop(movies.*) -- 테이블명.*
		  FROM movies;
		  ```
		- 이제 텍스트나 숫자, boolean 타입 뿐만이 아니라 우리가 가진 movies 테이블을 입력값으로 넣었음
		- ```sql
		  DROP FUNCTION is_hit_or_flop(movies);
		  
		  CREATE OR REPLACE FUNCTION is_hit_or_flop (movie movies)
		  RETURNS TABLE (hit_or_flop texxt, other_thing numeric) AS
		  $$
		    SELECT CASE
		      WHEN moyie. revenue > movie.budget THEN 'Hit'
		      WHEN movie. revenue ‹ movie.budget THEN 'Flop'
		      ELSE 'N/A'
		    END, 111111;
		  $$
		  LANGUAGE SQL;
		  
		  SELECT
		  	title,
		      (is_hit_or_flop(movies.*)).*
		  FROM movies;
		  ```
	- 14.3 Trigger Functions
		- PostgreSQL 에서 record가 업데이트 될 때 column이 갱신되지 않는 문제를 해결
		- Function Volatility Categories (특히 PostgreSQL)
			- VOLATILE: 인풋이 같아도 아웃풋이 달라질 수 있음
			- STABLE: 쿼리  실행 중에는 결과가 같지만, 외부 상태에 따라 달라질 수 있다.
			- IMMUTABLE: 입력이 같으면 결과가 항상 같음.
		- 데이터를 수정할 때 컬럼이 수정되지 않는 문제.. PostgreSQL 을 Trigger Functions 작성할 때는 plpsql을 써야한다.
			- ```sql
			  LANGUAGE plpgsql;
			  
			  CREATE TRIGGER updated_at
			  BEFORE UPDATE -- OF title
			  ON movies
			  FOR EACH ROW EXECUTE PROCEDURE set_updated();
			  ```
	- 14.4 Procedures
		- 함수는 무언가를 반환하게 되어있다.
		- functions은 DML 커맨드에서 호출한다.
-
- #SQLD
	- 기출문제
		- https://yunamom.tistory.com/category/IT%EC%9E%90%EA%B2%A9%EC%A6%9D%20%EA%B3%B5%EB%B6%80/SQLD%20%EA%B8%B0%EC%B6%9C%EB%AC%B8%EC%A0%9C
		- https://www.sqld.kr/main
		- https://cafe.naver.com/sqlpd/84701
		- [[SQLD 노란책 풀이]]
		-
- #DB #SQLD
	- 데이터 모델링의 이해
		- **식별자관계 vs. 비식별자 관계**
			- 자식 테이블의 PK에 부포 테이블  PK가 **포함**되어 있으면 식별자 관계, 아니라면 비식별자 관계
			- 주식별자 관계에서 자식테이블은 반드시 복합키를 가진다?
				- 자식 테이블이 **자체 식별자 없이 부모 PK만으로도 유일하다면 복합키가 아니어도 됨.**
					- ```sql
					  -- 부모 테이블
					  CREATE TABLE employee (
					      emp_id INT PRIMARY KEY,
					      name VARCHAR(100)
					  );
					  
					  -- 자식 테이블 (주식별자 관계, 단일 PK)
					  CREATE TABLE employee_card (
					      emp_id INT PRIMARY KEY,  -- 부모 PK만을 PK로 사용
					      card_number VARCHAR(20),
					  
					      FOREIGN KEY (emp_id) REFERENCES employee(emp_id)
					  );
					  ```
					- 이 경우 ==employee_card는 직원당 하나만 발급==되므로 emp_id 하나로 유일성 확보 → 복합키 불필요 → ==주식별자 관계이지만 단일 PK 가능==
				- “자식 주식별자 구성에 부모 주식별자 필요“는 원래 식별자 관계의 핵심 조건이지만,
				  비식별자 관계에서도 설계 의도에 따라 자식 PK 구성에 부모 PK를 포함할 수 있다.
				  단지 이 경우에는 “필수 조건”이 아니라 **“설계 선택“일 뿐**
				-
			-
- #SQL
	- https://mode.com/sql-tutorial
	-
- #PromptEngineering
	- https://docs.anthropic.com/ko/docs/build-with-claude/prompt-engineering/overview
	- ㅇ