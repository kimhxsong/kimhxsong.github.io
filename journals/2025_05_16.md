- 8시 17분 기상.
- 8시 49분 기상.
- #DD-CN 4/131
	- 파이썬 가상환경이 왜 필요할까.
	-
	-
- #LASER
- #CKA
	- [[CKA - Sec1. Introduction]]
	-
- #CKAD
- #AWSSAA
- #SQLD
	- https://brunch.co.kr/@ninehypheneight/6
-
- > #SQL마스터클래스
	- ### 4.12 GROUP BY Gotchas
		- GROUP BY 를 사용하지 않고 집계함수를 사용하면...
			- 모든 row가 마치 하나의 그룹처럼 병합된다. (= 전체 데이터 베이스를 하나의 그룹으로 간주)
			- SQLite에서 집계 함수가 적용되지 않은 열의 값은 해당 그룹 내의 ==임의의 행==에서 가져온다.
			- 이는 일반적으로 마지막 행의 값으로 보일 수 있지만, 보장되지 않습니다. 명확한 값을 원할 경우, 적절한 집계 함수나 서브쿼리를 사용하기.
		- 주의하자
			- GROUP BY를 실행하고 집계 함수를 사용하지 않는 경우에도  ==병합은 여전히 발생==
			  logseq.order-list-type:: number
			- GROUP BY하지 않은 column을 SELECT하면 어떨까? ==각 그룹의 마지막 row 값을 가져온다 (in SQLite)==, 임의의 행 & 보장되지 않음 이라고 기억하자.
			  logseq.order-list-type:: number
			- GROUP BY를 사용하지 않지만 여전히 집계함수를 사용하는 경우? 그룹 자체가 존재하지 않게 되고 ==데이터베이스 전체가 그룹==이 된다. 따라서 여전히 병합은 발생.
			  logseq.order-list-type:: number
			-
	- ### 4.13 Having Clause
		- WHERE과 비슷한데, ROW를 필터할 수 있게 하는 구문.
		- HAVING은 WHERE 다음에, 그리고 또 GROUP BY 다음에 실행된다.
		- WHERE은 집계함수(ex. AVG, SUM ..)를 볼 수 없다.
			- Using WHERE => ERROR!
				- ```sql
				  SELECT 
				  	release_date,
				  	round(AVG(rating), 2) AS avg_rating
				  FROM
				  	movies
				  WHERE
				      rating IS NOT NULL
				      AND release_date IS NOT NULL
				      AND avg_raing > 6 -- ERROR
				  GROUP BY
				      release_date 
				  ORDER BY
				      avg_rating DESC;  
				  ```
			- Using HAVING
				- ```sql
				  SELECT -- 5
				  	release_date,
				  	round(AVG(rating), 2) AS avg_rating
				  FROM -- 1
				  	movies
				  WHERE -- 2
				      rating IS NOT NULL AND release_date  IS NOT NULL
				  GROUP BY -- 3
				      release_date
				  HAVING -- 4
				  	avg_rating > 6
				  ORDER BY --6
				      avg_rating DESC;
				  ```
				- HAVING 에서는 집계 함수를 사용하여 생성된 참조를 사용하여 필터링 가능!
			- **Question**: 아무리 살펴봐도 어떻게 HAVING이 SELECT보다 먼저 실행되는지 이해할 수 없습니다. SELECT 문은 집계 함수를 사용하여 avg_rating을 생성하고 HAVING 절이 이를 참조하므로, 순서는 SELECT가 먼저이고 그다음에 HAVING이 되어야 하는 것 아닌가요?
				- **Answer**: HAVING이 SELECT 절에서 열이나 표현식을 참조할 수 있는 이유는 SQL 엔진이 실제 실행 전에 쿼리에 사용된 모든 열과 표현식을 식별하기 위해 패스를 수행하기 때문입니다. 이를 통해 SELECT가 아직 완전히 처리되지 않았음에도 불구하고 HAVING은 The SELECT에 무엇이 포함될지 “볼” 수 있습니다.
				  한 가지 주목할 점은 HAVING이 SELECT 열을 참조할 수는 있지만, 일반적으로 그룹 필터링이라는 의도된 목적에 더 부합하기 때문에 집계된 값이나 GROUP BY 절에 나타나는 열에만 HAVING을 사용하는 것이 좋은 관행으로 간주된다는 것입니다.
			- ### 4.14 Super Practice Part One
				- [built-in aggregate functions](https://www.sqlite.org/lang_aggfunc.html)
					-
					-
				-
			- ### 4.15 Super Practice Part Two
			-
			- ### 4.15 Super Practice Part Two
			-
-
	- 평균 평점이 6이상인 연도만 가져오고 싶다.
		-
-
- select 연도, AVG(평점) from 테이블 where rating is not null and 연도 is not NULLgroup by 연도 order by DESC
-
- 몰랐는데 Virtual Box Arm 버전이 출시됐나 보다. https://cjones-oracle.medium.com/virtualbox-7-1-supports-macos-arm64-hosts-280d02130c02
	- > Download VirtualBox from https://www.virtualbox.org/
	  >
	  > The changelog is at https://www.virtualbox.org/wiki/Changelog
	  >
	  >You can create virtual machines with many different OSs. I mostly use Oracle Linux. The ISOs are at https://yum.oracle.com/oracle-linux-isos.html
- https://tech.kakaoenterprise.com/178
-
- 이게 돼요?
	- https://tech.kakaoenterprise.com/154
	- https://tech.kakaoenterprise.com/171
-
- #devblog #subscribed
	- https://netpple.github.io/
-
-
- 서비스 개발자를 위한 컨테이너 뽀개기 https://tech.kakaoenterprise.com/150
  collapsed:: true
	- 주어진 컨테이너 기술 관련 글을 바탕으로 중요 개념을 카드 뉴스 형식으로 정리해드리겠습니다. 카드별로 핵심 내용을 간결하게 담았습니다.
	- # 카드 1: 컨테이너란?
	- 컨테이너는 격리된 환경과 제한된 리소스로 제어되는 프로세스입니다
	- 애플리케이션과 실행에 필요한 모든 것을 패키징하여 서버 환경에 의존하지 않고 독립적으로 실행 가능
	- 동일한 호스트에서 여러 애플리케이션이 서로 영향받지 않고 격리된 환경에서 실행됨
	- # 카드 2: 컨테이너 vs VM(가상머신)
	- VM: 별도의 게스트OS 필요, 강력한 격리, 다양한 OS 실행 가능, 리소스 사용량 큼
	- 컨테이너: 호스트OS 커널 공유, 경량화, 빠른 시작 속도, 적은 리소스 사용
	- 컨테이너는 VM보다 작고 빠르며 효율적이지만, 둘 다 클라우드에서 필요한 역할이 있음
	- # 카드 3: 컨테이너의 장점
	- 서버 환경에 의존하지 않는 일관된 실행 환경 제공
	- 패키징: 실행파일, 의존성 라이브러리, 설정 등 필요한 모든 것을 이미지로 통합
	- 빠른 시작과 적은 오버헤드로 효율적인 리소스 활용
	- 동일 환경에서 다른 프로세스의 영향을 받지 않는 격리성
	- # 카드 4: 클라우드란?
	- NIST 정의: "공유 구성이 가능한 컴퓨팅 리소스의 통합으로 어디서나 간편하게, 요청에 따라 네트워크를 통해 언제든 접근 가능한 모델"
	- 가상화와 API를 통해 컴퓨팅 리소스를 공유하고 요청 기반으로 제공
	- 최소한의 관리 노력으로 신속하게 자원 할당 및 제공
	- # 카드 5: 가상화 이해하기
	- 가상화: 실제가 아닌 하드웨어 환경을 만들어내는 기술
	- 주요 유형: 하이퍼바이저 가상화, 컨테이너(애플리케이션) 가상화, 네트워크 가상화
	- 호스트(Host): 가상화 소프트웨어를 구동하는 물리 시스템
	- 게스트(Guest): 하이퍼바이저 위에 설치되는 가상머신
	- # 카드 6: 컨테이너 기술의 발전
	- 컨테이너는 "프로세스 격리"라는 문제를 해결하기 위해 오랜 시간 발전
	- 도커(회사)는 2013년 기존 리눅스 기술을 모아 개발에 활용할 수 있는 "도커 플랫폼" 공개
	- 도커는 컨테이너 기술을 대중화했으나, 컨테이너 자체는 리눅스 커널 기술에 기반
	- # 카드 7: 쿠버네티스란?
	- 컨테이너 오케스트레이션 플랫폼: 컨테이너의 배포, 관리, 확장 자동화
	- 구글의 내부 시스템 'Borg'에서 발전, 2014년 오픈소스로 공개
	- 명세(작업지시서) 기반으로 다양한 "컨트롤러"가 협력하는 방식으로 동작
	- 사람의 개입 없이 배포부터 운영관리까지 자동화 가능
	- # 카드 8: API의 역할
	- API: 가상화된 하드웨어와 애플리케이션을 "추상화"하는 인터페이스 레이어
	- 리소스 요청 및 제어 방법을 표준화하여 인프라 체계 정의
	- 다양한 리소스 연결 및 오케스트레이션 도구에서 컨트롤러 제어
	- 컴퓨팅 리소스 할당, 가상 네트워크 구성, 컨테이너 배치 등 자동화
	- # 카드 9: 컨테이너 네트워크
	- 물리 IP 사용으로 인한 의존성 문제를 가상 네트워크로 해결
	- 컨테이너 간 통신을 위한 가상 네트워크 구성
	- 서로 다른 호스트의 컨테이너 간 가상 네트워크 통신 가능
	- 네트워크 가상화로 유연하고 단순한 구성 제공
	- # 카드 10: 컨테이너 파일시스템
	- 마운트 네임스페이스: 컨테이너 내부 파일시스템 구조를 독립적으로 유지
	- 오버레이 파일시스템: 효율적인 컨테이너 구조 구성
	- 컨테이너 이미지: 실행에 필요한 모든 것을 포함한 패키지