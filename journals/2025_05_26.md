- #Tools
	- audio hijack
	-
- #DD-CN
	- 지식 공유
		- [[리눅스 CLI 간략 가이드]] 30분
		- 빠진 내용 ...
			- 생각나는 것
				- chmod, chown
				- $?, $IFS
				- ERRNO
				- mount,
				- symbolic link
			- GPT Say..
			  collapsed:: true
				- 물론이야, 아래는 너가 작성한 리눅스 CLI 완전 가이드에서 **빠졌거나 추가하면 좋은 중요 항목들**을 마크다운 리스트로 정리한 내용이야:
				  
				  ---
				- ## **✅ 추가하면 좋은 중요 항목 정리**
				- ### **🔐 권한 및 소유권**
				- chmod: 파일 권한 변경
				- chown: 파일 소유자 및 그룹 변경
				- umask: 기본 권한 설정
				- ### **📁 파일 시스템**
				- mount: 파일 시스템 마운트
				- umount: 파일 시스템 마운트 해제
				- /etc/fstab: 부팅 시 자동 마운트 설정
				- ### **🔢 상태 및 오류 처리**
				- $?: 직전 명령의 종료 상태 확인 (0이면 성공, 0이 아니면 실패)
				- ERRNO: C 프로그래밍에서 시스템 호출 실패 시의 에러 번호 (perror, strerror 등과 함께 사용)
				- ### **🧠 프로세스 및 작업 관리**
				- ps, top, htop: 프로세스 목록 및 상태 확인
				- kill, pkill, killall: 프로세스 종료
				- nice, renice: 프로세스 우선순위 조정
				- watch: 주기적으로 명령 실행 결과 확인
				- ### **📦 파일 탐색 및 디스크**
				- df: 디스크 사용량
				- du: 디렉토리별 용량 확인
				- find: 파일 탐색
				- locate, updatedb: 인덱스 기반 파일 검색
				- ### **🔁 링크 및 파일 시스템 심화**
				- ln -s: 심볼릭 링크 생성
				- ls -li: inode 번호 확인
				- stat: 파일의 상세 메타정보 확인
				- ### **🧪 디버깅과 트러블슈팅**
				- strace: 시스템 콜 추적
				- lsof: 열려 있는 파일 목록 확인
				- dmesg: 커널 메시지 로그
				- /var/log: 시스템 로그 디렉토리
				- ### **🌐 네트워크 명령어**
				- ping, curl, wget: 네트워크 연결 확인 및 요청
				- netstat, ss: 포트 및 연결 상태 확인
				- ip, ifconfig: 네트워크 인터페이스 설정 및 확인
				- nmcli: NetworkManager CLI 도구
				- ### **🛠 유용한 고급 Shell 기능**
				- trap: 시그널 캡처 및 처리
				- set -e, set -x: 스크립트 디버깅용 옵션
-
- #SQL마스터클래스
	- 9.5 Joins Practice Pt.1
	  collapsed:: true
		- ```sql
		  -- 1. List all dogs with their breed names
		  SELECT
		      dogs.name,
		      breeds.name
		  FROM
		      dogs
		  JOIN breeds b
		          USING(breed_id);
		  
		  -- 2. Show all owners and their dogs (if they have any)
		  SELECT
		      o.name,
		      d.name
		  FROM
		      owners o
		  JOIN dogs d
		          USING(owner_id);
		  
		  -- 3. Display all breeds and the dogs of that breed (if any)
		  SELECT
		      b.name,
		      d.name
		  FROM
		      breeds b
		  JOIN dogs d
		          USING(breed_id);
		  
		  -- 4. List all dogs with their pet passport information and owner data (if avaliable)
		  SELECT
		      d.name,
		      pp.blood_type,
		      pp.allergies,
		      pp.last_checkup_date
		  FROM
		      dogs d
		  JOIN pet_passports pp
		          USING(dog_id);
		  
		  -- 5. Show all tricks and the dogs that know them
		  SELECT
		      t.name,
		      d.name
		  FROM
		      (
		          SELECT
		              tricks.name name,
		              dog_id
		          FROM
		              tricks
		          JOIN dog_tricks
		                  USING (trick_id)
		      ) AS t
		  JOIN 
		      dogs d
		          USING (dog_id);
		  
		  -- 6. Display all dogs that don't know a single trick
		  SELECT
		      d.name,
		      dt.trick_id
		  FROM
		      dogs d
		  LEFT JOIN dog_tricks dt
		          USING (dog_id)
		  WHERE
		      dt.trick_id IS NULL;
		  
		  ```
		- #Claude 내가 쓴 쿼리를 평가해주라..
			- 전반적으로 SQL 쿼리의 기본 구조는 잘 이해하고 있지만, 몇 가지 문제점들이 있습니다. 각 쿼리별로 평가해드리겠습니다.
				- ## 쿼리 1: 개와 품종명 조회 ✅
				  
				  ```
				  SELECT dogs.name, breeds.name
				  FROM dogs
				  JOIN breeds b USING(breed_id);
				  ```
				  
				  **문제점**: 별칭 `b`를 정의했지만 사용하지 않음. 일관성 부족.
				  **개선안**: `breeds b` → `breeds` 또는 별칭을 실제로 사용
				- ## 쿼리 2: 소유자와 개 조회 ❌
				  
				  ```
				  SELECT o.name, d.name
				  FROM owners o
				  JOIN dogs d USING(owner_id);
				  ```
				  
				  **문제점**: JOIN 방향이 잘못됨. 요구사항은 "모든 소유자와 그들의 개(있다면)"인데 INNER JOIN을 사용하면 개가 없는 소유자는 제외됨.
				  **개선안**: `LEFT JOIN` 사용 필요
				- ## 쿼리 3: 품종과 해당 품종의 개 조회 ❌
				  
				  ```
				  SELECT b.name, d.name
				  FROM breeds b
				  JOIN dogs d USING(breed_id);
				  ```
				  
				  **문제점**: 쿼리 2와 동일한 문제. "모든 품종과 그 품종의 개(있다면)"이므로 `LEFT JOIN` 필요.
				- ## 쿼리 4: 개와 펫 패스포트 정보 조회 ❌
				  
				  ```
				  SELECT d.name, pp.blood_type, pp.allergies, pp.last_checkup_date
				  FROM dogs d
				  JOIN pet_passports pp USING(dog_id);
				  ```
				  
				  **문제점**:
				- "소유자 데이터(if available)"라고 했는데 소유자 정보가 SELECT에 없음
				- 펫 패스포트가 없는 개는 제외됨
				- ## 쿼리 5: 트릭과 그 트릭을 아는 개들 ⚠️
				  복잡한 서브쿼리를 사용했는데, 더 간단하게 작성 가능:
				  
				  ```
				  -- 개선안
				  SELECT t.name, d.name
				  FROM tricks t
				  JOIN dog_tricks dt USING(trick_id)
				  JOIN dogs d USING(dog_id);
				  ```
				- ## 쿼리 6: 트릭을 모르는 개들 ✅
				  
				  ```
				  SELECT d.name, dt.trick_id
				  FROM dogs d
				  LEFT JOIN dog_tricks dt USING(dog_id)
				  WHERE dt.trick_id IS NULL;
				  ```
				  
				  **올바른 접근**: LEFT JOIN과 IS NULL 조건을 적절히 사용
				- ## 전체적인 문제점:
				- **JOIN 타입 선택 오류**: ==요구사항에서 "if any", "if available" 등의 표현이 있으면 보통 LEFT JOIN 사용==
				- **별칭 사용 불일치**: 정의한 별칭을 사용하지 않거나 일관성 부족
				- ==**요구사항 해석 미흡**: 필요한 컬럼이 빠지거나 잘못된 JOIN 방향==
				  
				  **점수**: 60/100 (기본 문법은 알고 있지만 JOIN 타입 선택과 요구사항 분석에서 개선 필요)
	- 9.6 Joins Practice Pt.2
	  collapsed:: true
		- ```sql
		  -- 1. Show all breeds and the count of dogs for each breed
		  SELECT b.name, d.name FROM breeds b JOIN dogs d USING (breed_id);
		  SELECT b.name, COUNT(d.name) AS cnt FROM breeds b JOIN dogs d USING (breed_id) GROUP BY (b.name) ORDER BY cnt DESC;
		  SELECT b.name, COUNT(d.name) AS cnt FROM breeds b LEFT JOIN dogs d USING (breed_id) GROUP BY (b.name) ORDER BY cnt DESC;
		  
		  -- 2. Display all owners with
		  -- the count of their dogs,
		  -- the average dog weight and the average dog age.
		  SELECT
		      o.name owner_name,
		      COUNT(d.name) total_count,
		      AVG(d.weight) avg_weight,
		      AVG((YEAR(CURDATE()) - YEAR(d.date_of_birth)) -- (한국식 나이 - 1)
		        - (
		          DATE_FORMAT(CURDATE(), '%m%d') < DATE_FORMAT(d.date_of_birth, '%m%d') -- 생일이 지나지 않았다면 
		      )) AS avg_age
		  FROM
		      owners o
		  JOIN dogs d
		  USING (owner_id)
		  GROUP BY
		      owner_name;
		  
		  
		  -- 3. Show all tricks and the number
		  -- of dogs that know each trick
		  -- ordered by popularity <=> order by number of dogs who learned each trick
		  SELECT
		      t.name trick,
		      COUNT(dt.dog_id) number_of_dogs
		  FROM
		      tricks t
		  JOIN dog_tricks dt
		          USING (trick_id)
		  GROUP BY
		      (trick)
		  ORDER BY
		      number_of_dogs DESC;Ï
		  
		  -- 4. Display all dogs along with
		  -- the count of tricks they knowÏ
		  SELECT
		      d.name dog_name,
		      COUNT(CASE WHEN dt.trick_id IS NULL THEN 0 ELSE 1 END) number_of_dogs
		  FROM
		      dogs d
		  LEFT JOIN dog_tricks dt
		          USING (dog_id)
		  GROUP BY
		      (dog_name);
		  
		  -- 5. List all owner with their
		  -- dogs and the tricks their dogs know
		  SELECT 
		      o.name owner_name,
		      d.name,
		      t.name
		  FROM
		      owners o
		  JOIN dogs d
		          USING (owner_id)
		  JOIN dog_tricks 
		          USING (dog_id)
		  JOIN tricks t
		          USING (trick_id);
		  ```
			- #Claude
				- 각 쿼리별로 평가해드리겠습니다:
				  collapsed:: true
					- ## 쿼리 1: 품종별 개 수 조회 ⚠️
					  
					  **첫 번째 쿼리**:
					  
					  ```
					  SELECT b.name, d.name FROM breeds b JOIN dogs d USING (breed_id);
					  ```
					  
					  **문제**: 개별 개들을 나열할 뿐, 카운트하지 않음
					  
					  **두 번째 쿼리**:
					  
					  ```
					  SELECT b.name, COUNT(d.name) AS cnt FROM breeds b JOIN dogs d USING (breed_id) GROUP BY (b.name) ORDER BY cnt DESC;
					  ```
					  
					  **문제점**:
					- `INNER JOIN` 사용 → 개가 없는 품종은 결과에서 제외됨
					- `RIGHT JOIN`을 사용해야 품종 없는 개 표시 가능
					- ## 쿼리 2: 소유자별 통계 ❌
					  
					  ```
					  SELECT
					  o.name owener_name  -- 쉼표 누락!
					  COUNT(d.name) total_count,
					  ```
					  
					  **문제점**:
					- **구문 오류**: `owener_name` 뒤에 쉼표(`,`) 누락
					- **오타**: `owener_name` → `owner_name`
					- **INNER JOIN** 사용 → 개가 없는 소유자 제외됨
					- **GROUP BY에서 별칭 사용** → 일부 MySQL 버전에서 오류 가능
					- ## 쿼리 3: 트릭별 인기도 ✅
					  
					  ```
					  SELECT
					  t.name trick,
					  COUNT(dt.dog_id) number_of_dogs
					  FROM tricks t
					  JOIN dog_tricks dt USING (trick_id)
					  GROUP BY (trick)
					  ORDER BY number_of_dogs DESC;
					  ```
					  
					  **거의 완벽!** 다만:
					- 아무도 모르는 트릭은 제외됨 (필요하다면 `LEFT JOIN` 사용)
					- 마지막에 `Ï` 문자 오타
					- ## 쿼리 4: 개별 개가 아는 트릭 수 ❌
					  
					  ```
					  SELECT
					  d.name dog_name,
					  COUNT(CASE WHEN dt.trick_id IS NULL THEN 0 ELSE 1 END) number_of_dogs
					  FROM dogs d
					  LEFT JOIN dog_tricks dt USING (dog_id)
					  GROUP BY (dog_name);
					  ```
					  
					  **문제점**:
					- **CASE WHEN 로직 오류**: `IS NULL`일 때 0을 반환하지만 `COUNT(0)`은 여전히 1로 카운트됨
					- **컬럼명 오류**: `number_of_dogs` → `number_of_tricks`가 적절
					  
					  **수정안**:
					  
					  ```
					  COUNT(dt.trick_id) -- NULL은 자동으로 제외되어 카운트됨
					  -- 또는
					  COUNT(CASE WHEN dt.trick_id IS NOT NULL THEN 1 END)
					  ```
					- ## 쿼리 5: 소유자-개-트릭 관계 ⚠️
					  
					  ```
					  SELECT
					  o.name owner_name,
					  d.name,
					  t.name
					  FROM owners o
					  JOIN dogs d USING (owner_id)
					  JOIN dog_tricks USING (dog_id)
					  JOIN tricks t USING (trick_id);
					  ```
					  
					  **문제점**:
					- **INNER JOIN만 사용** → 트릭을 모르는 개나 개가 없는 소유자는 제외
					- 요구사항이 "모든 소유자"라면 `LEFT JOIN` 필요
					- ## 전체 평가 점수:  **45/100**
					- ### 주요 개선 필요사항:
					- **구문 오류** 수정 (쉼표, 오타)
					- **JOIN 타입** 선택 개선 (LEFT JOIN vs INNER JOIN)
					- **집계 함수 로직** 정확히 이해
					- **요구사항 분석** 능력 향상
					- ### 잘한 점:
					- 기본적인 JOIN과 GROUP BY 구조 이해
					- 복잡한 나이 계산 로직 시도
					- 별칭 사용으로 가독성 향상
				- GROUP BY 할 때, 실무에서는 **데이터 품질을 100% 신뢰할 수 없으므로**  ==PRIMARY KEY를 포함하는 것이 더 안전한 선택==
			- 개선ver
				- ```sql
				  -- 1. Show all breeds and the count of dogs for each breed
				  -- 모든 품종을 표시하고, 품종 없는 개 0으로 표시
				  SELECT 
				      COALESCE(b.name, 'No breeds') AS breed_name, -- ! 시고르자브종 고려
				      COUNT(d.dog_id) AS dog_count
				  FROM breeds b
				  RIGHT JOIN dogs d USING (breed_id)
				  GROUP BY b.breed_id, b.name
				  ORDER BY dog_count DESC, breed_name;
				  
				  -- 2. Display all owners with the count of their dogs, 
				  -- the average dog weight and the average dog age
				  -- 모든 소유자를 표시하고, 개가 없는 소유자도 포함
				  SELECT
				      o.name AS owner_name,
				      COUNT(*) AS total_dogs,
				      ROUND(AVG(d.weight), 2) AS avg_weight,
				      -- ! 나이 계산을 좀 더 단순하게 수정
				      ROUND(AVG(TIMESTAMPDIFF(YEAR, d.date_of_birth, CURDATE())), 1) AS avg_age 
				  FROM owners o 
				  LEFT JOIN dogs d USING (owner_id)
				  GROUP BY o.owner_id, o.name
				  ORDER BY total_dogs DESC, owner_name;
				  
				  -- 3. Show all tricks and the number of dogs that know each trick
				  -- ordered by popularity (number of dogs who learned each trick)
				  -- 모든 트릭을 표시하고, 아무도 모르는 트릭은 0으로 표시
				  SELECT
				      t.name AS trick_name,
				      COUNT(*) AS number_of_dogs
				  FROM tricks t
				  LEFT JOIN dog_tricks dt USING (trick_id)
				  GROUP BY t.trick_id, t.name
				  ORDER BY number_of_dogs DESC, trick_name;
				  
				  -- 4. Display all dogs along with the count of tricks they know
				  -- 모든 개를 표시하고, 트릭을 모르는 개는 0으로 표시
				  SELECT
				      d.name AS dog_name,
				      COUNT(*) AS known_tricks
				  FROM dogs d
				  LEFT JOIN dog_tricks dt USING (dog_id)
				  GROUP BY d.dog_id, d.name
				  ORDER BY known_tricks DESC, dog_name;
				  
				  -- 5. List all owners with their dogs and the tricks their dogs know
				  -- 모든 소유자를 표시하되, 개나 트릭이 없는 경우도 포함
				  SELECT
				      o.name AS owner_name,
				      COALESCE(d.name, 'No dogs') AS dog_name,
				      COALESCE(dt.proficiency, 'No Proficiency') AS proficiency,
				      COALESCE(t.name, 'No tricks') AS trick_name
				  FROM owners o
				  LEFT JOIN dogs d USING (owner_id)
				  LEFT JOIN dog_tricks dt USING (dog_id)
				  LEFT JOIN tricks t USING (trick_id)
				  ORDER BY owner_name, dog_name, trick_name;
				  
				  -- 보너스: 5번의 대안 - 소유자별로 개와 트릭을 집계해서 보여주기
				  SELECT
				      o.name AS owner_name,
				      COUNT(DISTINCT d.dog_id) AS total_dogs,
				      COUNT(DISTINCT dt.trick_id) AS total_unique_tricks,
				      GROUP_CONCAT(DISTINCT d.name ORDER BY d.name SEPARATOR ', ') AS dog_names,
				      GROUP_CONCAT(DISTINCT t.name ORDER BY t.name SEPARATOR ', ') AS known_tricks
				  FROM owners o
				  LEFT JOIN dogs d USING (owner_id)
				  LEFT JOIN dog_tricks dt USING (dog_id)
				  LEFT JOIN tricks t USING (trick_id)
				  GROUP BY o.owner_id, o.name
				  ORDER BY total_dogs DESC, owner_name;
				  ```
				-
			- 만 나이 계산하기 with TIMESTAMPDIFF
				- AVG(TIMESTAMPDIFF(YEAR, dogs.date_of_birth, CURDATE())):
			- COALESCE
				- COALESCE(expr1, expr2, ..., exprN)은 왼쪽에서 오른쪽으로 값을 검사해서 NULL이 아닌 첫 번째 값을 반환합니다.
				-
	- 9.7 Joins Practice Pt.3
	  collapsed:: true
		- ```sql
		  -- 1. Show all breeds with their
		  -- average dog weight and typical lifespan
		  SELECT
		      b.name,
		      avg(d.weight),
		      b.typical_lifespan
		  FROM
		      breeds b
		  RIGHT JOIN dogs d
		          USING (breed_id)
		  GROUP BY
		      (b.breed_id)
		  ORDER BY
		      b.name ASC
		      
		  -- 2. Display all dogs with their
		  -- latest checkup date
		  -- and the time since their last checkup
		  SELECT 
		      d.name,
		      pp.last_checkup_date,
		      DATEDIFF(CURDATE(), pp.last_checkup_date) AS since_last_checkup
		  FROM
		      dogs d
		  LEFT JOIN pet_passports pp
		          USING (dog_id);
		          
		  SELECT 
		      d.name,
		      pp.last_checkup_date,
		  	TIMESTAMPDIFF(DAY, pp.last_checkup_date, CURDATE() ) AS since_last_checkup
		  FROM
		      dogs d
		  JOIN pet_passports pp
		          USING (dog_id);
		  
		  -- 3. Display all breeds with the name
		  -- of the heaviest dog of that breed
		  SELECT
		      b.name,
		      d.name
		  FROM
		      breeds b
		  JOIN dogs d
		          USING(breed_id)
		  WHERE
		      d.weight = (
		          SELECT
		              MAX(d2.weight)
		          FROM
		              dogs d2
		          WHERE
		              d2.breed_id = d.breed_id
		      );
		  
		  -- 4. List all tricks with the name
		  -- of the dog who learned it most recently
		  SELECT
		      t.name,
		      d.name,
		      dt.date_learned
		  FROM
		      tricks t
		  JOIN dog_tricks dt
		          USING(trick_id)
		  JOIN dogs d
		          USING(dog_id)
		  WHERE
		      dt.date_learned = (
		          SELECT
		              MAX(dt2.date_learned)
		          FROM
		              dog_tricks dt2
		          WHERE
		              dt2.trick_id = t.trick_id
		          GROUP BY
		              dt2.trick_id
		      );
		  ```
		- #SQL [[DATE가 집계 함수 및 비교 연산에서 평가되는 방식]]
		-
	- ### 10. Normalization
	- 10.1 Normalizing Status
	  collapsed:: true
		- movie status 정규화 하지 말아야하는 이유
			- 값의 종류가 적고, 고정되어 있음 enum,
			- status는 movie 와 논리적으로 연결되어 있음
			- +++GPT
				- JOIN의 비용이 오히려 커질 수 있음
		- movie status 정규화 해야 하는 이유
			- 데이터 확장성
				- status를 구성하는 요소에 설명 추가 가능
			- 비개발자 status 생성 및 관리할 수 있도록. ..
			- +++GPT
				- 데이터 일관성 & 제약조건
				- 유비보수 편의성
		- #TroubleShooting
			- json dataimport 할 때 오류 줄이려고 ENUM 을 VARCHAR(50)으로 바꿨었다. 이 때문에 insert ... select  쓰니가 data truncated 된다고 에러 뜬 거였음.
		- 정규화 과정
			- statuses 테이블 만들기
			  logseq.order-list-type:: number
				- ```sql
				  USE movies;
				  
				  CREATE TABLE statuses (
				      status_id BIGINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
				      status_name ENUM (
				          'Cancelled',
				          'In Production',
				          'Planned',
				          'Post Production',
				          'Released',
				          'Rumored'
				      ) NOT NULL,
				      explanation TEXT,
				      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
				      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON
				      UPDATE
				          CURRENT_TIMESTAMP NOT NULL
				  );
				  
				  DROP TABLE statuses;
				  
				  SELECT
				      status
				  FROM
				      movies
				  GROUP BY
				      status;
				  
				  INSERT
				      INTO
				      statuses (status_name)
				  SELECT
				      status
				  FROM
				      movies
				  GROUP BY
				      status;
				  ```
			- movies 테이블 칼럼 추가하기
			  logseq.order-list-type:: number
				- ```sql
				  ALTER TABLE movies ADD COLUMN status_id BIGINT UNSIGNED;
				  ```
			- foreign key 제약 조건 추가하기
			  logseq.order-list-type:: number
				- ```sql
				  ALTER TABLE movies ADD CONSTRAINT fk_status FOREIGN KEY (status_id)
				  references statuses (status_id) ON DELETE SET NULL;
				  ```
			- movies 테이블에서 row 별로 status_name을 가져다가 해당 status를 찾아서 그 id 를 status_id column에 넣는 것
			  logseq.order-list-type:: number
				- ```sql
				  UPDATE movies SET status_id = (SELECT status_id FROM statuses
				                                 WHERE status_name = movies.status);
				  ```
			- status 칼럼 삭제
			  logseq.order-list-type:: number
				- ```sql
				  ALTER TABLE movies DROP COLUMN status;
				  ```
	- 10.2 Normalizing Directors
	  collapsed:: true
		-
	- 10.3 Normalizing Original Language
	- 10.4 Normalizing Countries
	- 10.5 Unions
	- 10.6 Conclusions
	-