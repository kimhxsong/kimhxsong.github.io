- #DD-CN
	- 지식 공유
		- [[리눅스 CLI 간략 가이드]] 30분
		- 빠진 내용 ...
			- 생각나는 것
				- chmod, chown
				- $?, $IFS
				- ERRNO
				- mount,
				- symbolic link
			- GPT Say..
			  collapsed:: true
				- 물론이야, 아래는 너가 작성한 리눅스 CLI 완전 가이드에서 **빠졌거나 추가하면 좋은 중요 항목들**을 마크다운 리스트로 정리한 내용이야:
				  
				  ---
				- ## **✅ 추가하면 좋은 중요 항목 정리**
				- ### **🔐 권한 및 소유권**
				- chmod: 파일 권한 변경
				- chown: 파일 소유자 및 그룹 변경
				- umask: 기본 권한 설정
				- ### **📁 파일 시스템**
				- mount: 파일 시스템 마운트
				- umount: 파일 시스템 마운트 해제
				- /etc/fstab: 부팅 시 자동 마운트 설정
				- ### **🔢 상태 및 오류 처리**
				- $?: 직전 명령의 종료 상태 확인 (0이면 성공, 0이 아니면 실패)
				- ERRNO: C 프로그래밍에서 시스템 호출 실패 시의 에러 번호 (perror, strerror 등과 함께 사용)
				- ### **🧠 프로세스 및 작업 관리**
				- ps, top, htop: 프로세스 목록 및 상태 확인
				- kill, pkill, killall: 프로세스 종료
				- nice, renice: 프로세스 우선순위 조정
				- watch: 주기적으로 명령 실행 결과 확인
				- ### **📦 파일 탐색 및 디스크**
				- df: 디스크 사용량
				- du: 디렉토리별 용량 확인
				- find: 파일 탐색
				- locate, updatedb: 인덱스 기반 파일 검색
				- ### **🔁 링크 및 파일 시스템 심화**
				- ln -s: 심볼릭 링크 생성
				- ls -li: inode 번호 확인
				- stat: 파일의 상세 메타정보 확인
				- ### **🧪 디버깅과 트러블슈팅**
				- strace: 시스템 콜 추적
				- lsof: 열려 있는 파일 목록 확인
				- dmesg: 커널 메시지 로그
				- /var/log: 시스템 로그 디렉토리
				- ### **🌐 네트워크 명령어**
				- ping, curl, wget: 네트워크 연결 확인 및 요청
				- netstat, ss: 포트 및 연결 상태 확인
				- ip, ifconfig: 네트워크 인터페이스 설정 및 확인
				- nmcli: NetworkManager CLI 도구
				- ### **🛠 유용한 고급 Shell 기능**
				- trap: 시그널 캡처 및 처리
				- set -e, set -x: 스크립트 디버깅용 옵션
			-
		-
- #SQL마스터클래스
	- 9.5 Joins Practice Pt.1
		- ```sql
		  -- 1. List all dogs with their breed names
		  SELECT
		      dogs.name,
		      breeds.name
		  FROM
		      dogs
		  JOIN breeds b
		          USING(breed_id);
		  
		  -- 2. Show all owners and their dogs (if they have any)
		  SELECT
		      o.name,
		      d.name
		  FROM
		      owners o
		  JOIN dogs d
		          USING(owner_id);
		  
		  -- 3. Display all breeds and the dogs of that breed (if any)
		  SELECT
		      b.name,
		      d.name
		  FROM
		      breeds b
		  JOIN dogs d
		          USING(breed_id);
		  
		  -- 4. List all dogs with their pet passport information and owner data (if avaliable)
		  SELECT
		      d.name,
		      pp.blood_type,
		      pp.allergies,
		      pp.last_checkup_date
		  FROM
		      dogs d
		  JOIN pet_passports pp
		          USING(dog_id);
		  
		  -- 5. Show all tricks and the dogs that know them
		  SELECT
		      t.name,
		      d.name
		  FROM
		      (
		          SELECT
		              tricks.name name,
		              dog_id
		          FROM
		              tricks
		          JOIN dog_tricks
		                  USING (trick_id)
		      ) AS t
		  JOIN 
		      dogs d
		          USING (dog_id);
		  
		  -- 6. Display all dogs that don't know a single trick
		  SELECT
		      d.name,
		      dt.trick_id
		  FROM
		      dogs d
		  LEFT JOIN dog_tricks dt
		          USING (dog_id)
		  WHERE
		      dt.trick_id IS NULL;
		  
		  ```
		- #Claude 내가 쓴 쿼리를 평가해주라..
			- 전반적으로 SQL 쿼리의 기본 구조는 잘 이해하고 있지만, 몇 가지 문제점들이 있습니다. 각 쿼리별로 평가해드리겠습니다.
				- ## 쿼리 1: 개와 품종명 조회 ✅
				  
				  ```
				  SELECT dogs.name, breeds.name
				  FROM dogs
				  JOIN breeds b USING(breed_id);
				  ```
				  
				  **문제점**: 별칭 `b`를 정의했지만 사용하지 않음. 일관성 부족.
				  **개선안**: `breeds b` → `breeds` 또는 별칭을 실제로 사용
				- ## 쿼리 2: 소유자와 개 조회 ❌
				  
				  ```
				  SELECT o.name, d.name
				  FROM owners o
				  JOIN dogs d USING(owner_id);
				  ```
				  
				  **문제점**: JOIN 방향이 잘못됨. 요구사항은 "모든 소유자와 그들의 개(있다면)"인데 INNER JOIN을 사용하면 개가 없는 소유자는 제외됨.
				  **개선안**: `LEFT JOIN` 사용 필요
				- ## 쿼리 3: 품종과 해당 품종의 개 조회 ❌
				  
				  ```
				  SELECT b.name, d.name
				  FROM breeds b
				  JOIN dogs d USING(breed_id);
				  ```
				  
				  **문제점**: 쿼리 2와 동일한 문제. "모든 품종과 그 품종의 개(있다면)"이므로 `LEFT JOIN` 필요.
				- ## 쿼리 4: 개와 펫 패스포트 정보 조회 ❌
				  
				  ```
				  SELECT d.name, pp.blood_type, pp.allergies, pp.last_checkup_date
				  FROM dogs d
				  JOIN pet_passports pp USING(dog_id);
				  ```
				  
				  **문제점**:
				- "소유자 데이터(if available)"라고 했는데 소유자 정보가 SELECT에 없음
				- 펫 패스포트가 없는 개는 제외됨
				- ## 쿼리 5: 트릭과 그 트릭을 아는 개들 ⚠️
				  복잡한 서브쿼리를 사용했는데, 더 간단하게 작성 가능:
				  
				  ```
				  -- 개선안
				  SELECT t.name, d.name
				  FROM tricks t
				  JOIN dog_tricks dt USING(trick_id)
				  JOIN dogs d USING(dog_id);
				  ```
				- ## 쿼리 6: 트릭을 모르는 개들 ✅
				  
				  ```
				  SELECT d.name, dt.trick_id
				  FROM dogs d
				  LEFT JOIN dog_tricks dt USING(dog_id)
				  WHERE dt.trick_id IS NULL;
				  ```
				  
				  **올바른 접근**: LEFT JOIN과 IS NULL 조건을 적절히 사용
				- ## 전체적인 문제점:
				- **JOIN 타입 선택 오류**: ==요구사항에서 "if any", "if available" 등의 표현이 있으면 보통 LEFT JOIN 사용==
				- **별칭 사용 불일치**: 정의한 별칭을 사용하지 않거나 일관성 부족
				- ==**요구사항 해석 미흡**: 필요한 컬럼이 빠지거나 잘못된 JOIN 방향==
				  
				  **점수**: 60/100 (기본 문법은 알고 있지만 JOIN 타입 선택과 요구사항 분석에서 개선 필요)
	- 9.6 Joins Practice Pt.2
		- ```sql
		  -- 1. Show all breeds and the count of dogs for each breed
		  SELECT b.name, d.name FROM breeds b JOIN dogs d USING (breed_id);
		  SELECT b.name, COUNT(d.name) AS cnt FROM breeds b JOIN dogs d USING (breed_id) GROUP BY (b.name) ORDER BY cnt DESC;
		  SELECT b.name, COUNT(d.name) AS cnt FROM breeds b LEFT JOIN dogs d USING (breed_id) GROUP BY (b.name) ORDER BY cnt DESC;
		  
		  -- 2. Display all owners with
		  -- the count of their dogs,
		  -- the average dog weight and the average dog age.
		  SELECT
		      o.name owner_name,
		      COUNT(d.name) total_count,
		      AVG(d.weight) avg_weight,
		      AVG((YEAR(CURDATE()) - YEAR(d.date_of_birth)) -- (한국식 나이 - 1)
		        - (
		          DATE_FORMAT(CURDATE(), '%m%d') < DATE_FORMAT(d.date_of_birth, '%m%d') -- 생일이 지나지 않았다면 
		      )) AS avg_age
		  FROM
		      owners o
		  JOIN dogs d
		  USING (owner_id)
		  GROUP BY
		      owner_name;
		  
		  
		  -- 3. Show all tricks and the number
		  -- of dogs that know each trick
		  -- ordered by popularity <=> order by number of dogs who learned each trick
		  SELECT
		      t.name trick,
		      COUNT(dt.dog_id) number_of_dogs
		  FROM
		      tricks t
		  JOIN dog_tricks dt
		          USING (trick_id)
		  GROUP BY
		      (trick)
		  ORDER BY
		      number_of_dogs DESC;Ï
		  
		  -- 4. Display all dogs along with
		  -- the count of tricks they knowÏ
		  SELECT
		      d.name dog_name,
		      COUNT(CASE WHEN dt.trick_id IS NULL THEN 0 ELSE 1 END) number_of_dogs
		  FROM
		      dogs d
		  LEFT JOIN dog_tricks dt
		          USING (dog_id)
		  GROUP BY
		      (dog_name);
		  
		  -- 5. List all owner with their
		  -- dogs and the tricks their dogs know
		  SELECT 
		      o.name owner_name,
		      d.name,
		      t.name
		  FROM
		      owners o
		  JOIN dogs d
		          USING (owner_id)
		  JOIN dog_tricks 
		          USING (dog_id)
		  JOIN tricks t
		          USING (trick_id);
		  ```
			- #Claude
				- 각 쿼리별로 평가해드리겠습니다:
				  collapsed:: true
					- ## 쿼리 1: 품종별 개 수 조회 ⚠️
					  
					  **첫 번째 쿼리**:
					  
					  ```
					  SELECT b.name, d.name FROM breeds b JOIN dogs d USING (breed_id);
					  ```
					  
					  **문제**: 개별 개들을 나열할 뿐, 카운트하지 않음
					  
					  **두 번째 쿼리**:
					  
					  ```
					  SELECT b.name, COUNT(d.name) AS cnt FROM breeds b JOIN dogs d USING (breed_id) GROUP BY (b.name) ORDER BY cnt DESC;
					  ```
					  
					  **문제점**:
					- `INNER JOIN` 사용 → 개가 없는 품종은 결과에서 제외됨
					- `RIGHT JOIN`을 사용해야 품종 없는 개 표시 가능
					- ## 쿼리 2: 소유자별 통계 ❌
					  
					  ```
					  SELECT
					  o.name owener_name  -- 쉼표 누락!
					  COUNT(d.name) total_count,
					  ```
					  
					  **문제점**:
					- **구문 오류**: `owener_name` 뒤에 쉼표(`,`) 누락
					- **오타**: `owener_name` → `owner_name`
					- **INNER JOIN** 사용 → 개가 없는 소유자 제외됨
					- **GROUP BY에서 별칭 사용** → 일부 MySQL 버전에서 오류 가능
					- ## 쿼리 3: 트릭별 인기도 ✅
					  
					  ```
					  SELECT
					  t.name trick,
					  COUNT(dt.dog_id) number_of_dogs
					  FROM tricks t
					  JOIN dog_tricks dt USING (trick_id)
					  GROUP BY (trick)
					  ORDER BY number_of_dogs DESC;
					  ```
					  
					  **거의 완벽!** 다만:
					- 아무도 모르는 트릭은 제외됨 (필요하다면 `LEFT JOIN` 사용)
					- 마지막에 `Ï` 문자 오타
					- ## 쿼리 4: 개별 개가 아는 트릭 수 ❌
					  
					  ```
					  SELECT
					  d.name dog_name,
					  COUNT(CASE WHEN dt.trick_id IS NULL THEN 0 ELSE 1 END) number_of_dogs
					  FROM dogs d
					  LEFT JOIN dog_tricks dt USING (dog_id)
					  GROUP BY (dog_name);
					  ```
					  
					  **문제점**:
					- **CASE WHEN 로직 오류**: `IS NULL`일 때 0을 반환하지만 `COUNT(0)`은 여전히 1로 카운트됨
					- **컬럼명 오류**: `number_of_dogs` → `number_of_tricks`가 적절
					  
					  **수정안**:
					  
					  ```
					  COUNT(dt.trick_id) -- NULL은 자동으로 제외되어 카운트됨
					  -- 또는
					  COUNT(CASE WHEN dt.trick_id IS NOT NULL THEN 1 END)
					  ```
					- ## 쿼리 5: 소유자-개-트릭 관계 ⚠️
					  
					  ```
					  SELECT
					  o.name owner_name,
					  d.name,
					  t.name
					  FROM owners o
					  JOIN dogs d USING (owner_id)
					  JOIN dog_tricks USING (dog_id)
					  JOIN tricks t USING (trick_id);
					  ```
					  
					  **문제점**:
					- **INNER JOIN만 사용** → 트릭을 모르는 개나 개가 없는 소유자는 제외
					- 요구사항이 "모든 소유자"라면 `LEFT JOIN` 필요
					- ## 전체 평가 점수:  **45/100**
					- ### 주요 개선 필요사항:
					- **구문 오류** 수정 (쉼표, 오타)
					- **JOIN 타입** 선택 개선 (LEFT JOIN vs INNER JOIN)
					- **집계 함수 로직** 정확히 이해
					- **요구사항 분석** 능력 향상
					- ### 잘한 점:
					- 기본적인 JOIN과 GROUP BY 구조 이해
					- 복잡한 나이 계산 로직 시도
					- 별칭 사용으로 가독성 향상
				- GROUP BY 할 때, 실무에서는 **데이터 품질을 100% 신뢰할 수 없으므로**  ==PRIMARY KEY를 포함하는 것이 더 안전한 선택==
			- 개선ver
				- ```sql
				  -- 1. Show all breeds and the count of dogs for each breed
				  -- 모든 품종을 표시하고, 품종 없는 개 0으로 표시
				  SELECT 
				      COALESCE(b.name, 'No breeds') AS breed_name, -- ! 시고르자브종 고려
				      COUNT(d.dog_id) AS dog_count
				  FROM breeds b
				  RIGHT JOIN dogs d USING (breed_id)
				  GROUP BY b.breed_id, b.name
				  ORDER BY dog_count DESC, breed_name;
				  
				  -- 2. Display all owners with the count of their dogs, 
				  -- the average dog weight and the average dog age
				  -- 모든 소유자를 표시하고, 개가 없는 소유자도 포함
				  SELECT
				      o.name AS owner_name,
				      COUNT(*) AS total_dogs,
				      ROUND(AVG(d.weight), 2) AS avg_weight,
				      -- ! 나이 계산을 좀 더 단순하게 수정
				      ROUND(AVG(TIMESTAMPDIFF(YEAR, d.date_of_birth, CURDATE())), 1) AS avg_age 
				  FROM owners o 
				  LEFT JOIN dogs d USING (owner_id)
				  GROUP BY o.owner_id, o.name
				  ORDER BY total_dogs DESC, owner_name;
				  
				  -- 3. Show all tricks and the number of dogs that know each trick
				  -- ordered by popularity (number of dogs who learned each trick)
				  -- 모든 트릭을 표시하고, 아무도 모르는 트릭은 0으로 표시
				  SELECT
				      t.name AS trick_name,
				      COUNT(*) AS number_of_dogs
				  FROM tricks t
				  LEFT JOIN dog_tricks dt USING (trick_id)
				  GROUP BY t.trick_id, t.name
				  ORDER BY number_of_dogs DESC, trick_name;
				  
				  -- 4. Display all dogs along with the count of tricks they know
				  -- 모든 개를 표시하고, 트릭을 모르는 개는 0으로 표시
				  SELECT
				      d.name AS dog_name,
				      COUNT(*) AS known_tricks
				  FROM dogs d
				  LEFT JOIN dog_tricks dt USING (dog_id)
				  GROUP BY d.dog_id, d.name
				  ORDER BY known_tricks DESC, dog_name;
				  
				  -- 5. List all owners with their dogs and the tricks their dogs know
				  -- 모든 소유자를 표시하되, 개나 트릭이 없는 경우도 포함
				  SELECT
				      o.name AS owner_name,
				      COALESCE(d.name, 'No dogs') AS dog_name,
				      COALESCE(dt.proficiency, 'No Proficiency') AS proficiency,
				      COALESCE(t.name, 'No tricks') AS trick_name
				  FROM owners o
				  LEFT JOIN dogs d USING (owner_id)
				  LEFT JOIN dog_tricks dt USING (dog_id)
				  LEFT JOIN tricks t USING (trick_id)
				  ORDER BY owner_name, dog_name, trick_name;
				  
				  -- 보너스: 5번의 대안 - 소유자별로 개와 트릭을 집계해서 보여주기
				  SELECT
				      o.name AS owner_name,
				      COUNT(DISTINCT d.dog_id) AS total_dogs,
				      COUNT(DISTINCT dt.trick_id) AS total_unique_tricks,
				      GROUP_CONCAT(DISTINCT d.name ORDER BY d.name SEPARATOR ', ') AS dog_names,
				      GROUP_CONCAT(DISTINCT t.name ORDER BY t.name SEPARATOR ', ') AS known_tricks
				  FROM owners o
				  LEFT JOIN dogs d USING (owner_id)
				  LEFT JOIN dog_tricks dt USING (dog_id)
				  LEFT JOIN tricks t USING (trick_id)
				  GROUP BY o.owner_id, o.name
				  ORDER BY total_dogs DESC, owner_name;
				  ```
				-
			- 만 나이 계산하기 with TIMESTAMPDIFF
				- AVG(TIMESTAMPDIFF(YEAR, dogs.date_of_birth, CURDATE())):
			- COALESCE
				- COALESCE(expr1, expr2, ..., exprN)은 왼쪽에서 오른쪽으로 값을 검사해서 NULL이 아닌 첫 번째 값을 반환합니다.
				-
	- 9.7 Joins Practice Pt.3
		- ```sql
		  -- 1. Show all breeds with their
		  -- average dog weight and typical lifespan
		  -- 2. Display all dogs with their
		  -- latest checkup date
		  -- and the time since their last checkup
		  -- 3. Display all breeds with the name
		  -- of the heaviest dog of that breed
		  -- 4. List all tricks with the name
		  -- of the dog who learned it most recently
		  ```
	-