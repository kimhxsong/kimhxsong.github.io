- **`collections`**: 특수 컨테이너 자료형.
	- **`collections.deque`**: 양쪽 끝에서 빠른 추가/삭제가 가능한 큐 (C++의 `std::deque`). 큐(Queue)나 스택(Stack) 구현에 유용합니다.
	- **`collections.Counter`**: 해시 가능한 객체의 개수를 세는 데 사용되는 딕셔너리 서브클래스. C++에서 `map<T, int>`를 사용하여 빈도수를 세는 것을 대체합니다.
- **`heapq`**: 힙 큐 알고리즘 (C++의 `std::priority_queue`와 유사). 기본적으로 최소 힙(min-heap)을 제공합니다. 최대 힙을 구현하려면 요소를 튜플로 저장하고 우선순위를 음수로 설정하는 트릭을 사용합니다.
  <!----><!----><!----><!----><!----><!----><!----><!----><!---->
  
  Python
  
  <!----><!----><!---->
  
  <!---->
  
  <!---->
  
  ```
  import heapq
  min_heap = []
  heapq.heappush(min_heap, 5) # 힙에 요소 추가
  print(heapq.heappop(min_heap)) # 힙에서 가장 작은 요소 제거 및 반환
  ```
  
  <!----><!----><!---->
  
  <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->
- **`itertools`**: 효율적인 반복을 위한 함수. C++에서 순열, 조합 등을 직접 구현하는 대신 파이썬에서는 이 모듈을 활용합니다.
	- `itertools.permutations(iterable, r)`: 순열
	- `itertools.combinations(iterable, r)`: 조합
	- `itertools.product(*iterables)`: 데카르트 곱 (중첩 `for` 루프 대체)
	- `itertools.accumulate(iterable)`: 누적 합 (또는 다른 이진 연산). C++의 `accumulate`와 동일합니다.
- **`functools`**: 고차 함수 관련.
	- `functools.lru_cache`: 재귀 함수 등에 **메모이제이션(Memoization)**을 쉽게 적용할 수 있는 데코레이터. 동적 계획법(Dynamic Programming) 문제에서 유용합니다.
- **`bisect`**: 정렬된 리스트에서 이진 탐색을 지원하는 함수. C++의 `lower_bound()`, `upper_bound()`에 해당합니다.
	- `bisect.bisect_left(a, x)`: 리스트 `a`에 `x`를 삽입할 때 `a[i-1] < x <= a[i]`를 만족하는 가장 왼쪽 인덱스를 반환.
	- `bisect.bisect_right(a, x)`: 리스트 `a`에 `x`를 삽입할 때 `a[i-1] <= x < a[i]`를 만족하는 가장 오른쪽 인덱스를 반환.
	  
	  ---
- ## 8. 입출력 (Input/Output)
- ### 8.1. 기본 입출력
- **입력**:
	- `변수 = input()`: 한 줄 입력 (문자열로 반환)
	- `변수 = int(input())`: 정수 입력
	- `변수1, 변수2 = map(int, input().split())`: 공백으로 구분된 여러 정수 입력
	- `리스트 = list(map(int, input().split()))`: 공백으로 구분된 여러 정수를 리스트로 입력
- **출력**:
	- `print(변수)`
	- `print(f"결과: {변수}")` (f-string, 파이썬 3.6 이상. C++의 `printf` 서식 지정 출력과 유사)
- ### 8.2. 빠른 입출력 (대량의 입력 처리 시 필수)
- `import sys`: 모듈 임포트
- `input = sys.stdin.readline`: `input()` 함수를 `sys.stdin.readline`으로 재정의하여 입력 속도를 향상시킵니다. 이 경우 입력받는 문자열 끝에 개행 문자가 붙으므로 `.rstrip()`으로 제거하는 것을 잊지 마세요.
  
  ---
- ## 9. 알고리즘 특화 패턴 및 팁
  
  C++ 교안 목차에는 명시적으로 없지만, 알고리즘 문제 풀이에서 파이썬 사용 시 특히 중요하고 자주 활용되는 패턴들입니다.
- ### 9.1. 프리픽스 썸 (Prefix Sum)
  
  배열의 특정 인덱스까지의 원소들의 합을 미리 계산해 놓는 기법입니다. 특정 구간의 합을 O(1)에 구할 수 있어 매우 유용합니다.
  
  <!----><!----><!----><!----><!----><!----><!----><!----><!---->
  
  Python
  
  <!----><!----><!---->
  
  <!---->
  
  <!---->
  
  ```
  # 리스트 arr의 프리픽스 썸 계산
  arr = [10, 20, 30, 40, 50]
  prefix_sum = [0] * (len(arr) + 1) # 0번 인덱스는 0으로 초기화
  for i in range(len(arr)):
    prefix_sum[i+1] = prefix_sum[i] + arr[i]
  
  # 구간 [start_idx, end_idx)의 합은 prefix_sum[end_idx] - prefix_sum[start_idx]
  # 예: 인덱스 1부터 3까지 (arr[1], arr[2])의 합: 20 + 30 = 50
  print(prefix_sum[3] - prefix_sum[1]) # 50
  ```
  
  <!----><!----><!---->
  
  <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->
  
  `itertools.accumulate()`를 활용하면 더욱 간결하게 구현할 수 있습니다.
- ### 9.2. 투 포인터 (Two Pointers)
  
  두 개의 포인터(인덱스)를 사용하여 배열 또는 리스트의 특정 구간을 탐색하거나 조건을 만족하는 쌍을 효율적으로 찾는 알고리즘입니다. 주로 정렬된 배열에서 사용됩니다.
  
  <!----><!----><!----><!----><!----><!----><!----><!----><!---->
  
  Python
  
  <!----><!----><!---->
  
  <!---->
  
  <!---->
  
  ```
  # 정렬된 배열에서 두 수의 합이 target_sum이 되는 쌍 찾기
  arr = [1, 2, 3, 4, 5]
  target_sum = 7
  left, right = 0, len(arr) - 1
  
  while left < right:
    current_sum = arr[left] + arr[right]
    if current_sum == target_sum:
        print(f"({arr[left]}, {arr[right]})")
        break
    elif current_sum < target_sum:
        left += 1
    else: # current_sum > target_sum
        right -= 1
  ```
  
  <!----><!----><!---->
  
  <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->
- ### 9.3. 슬라이딩 윈도우 (Sliding Window)
  
  고정된 크기 또는 가변 크기의 윈도우(구간)를 배열/리스트 위에서 이동시키면서 특정 조건을 만족하는 구간을 찾는 기법입니다. 연속된 부분 배열의 합, 최대/최소값 등을 구할 때 활용됩니다.
  
  <!----><!----><!----><!----><!----><!----><!----><!----><!---->
  
  Python
  
  <!----><!----><!---->
  
  <!---->
  
  <!---->
  
  ```
  # 크기 k인 윈도우의 최대 합 찾기
  arr = [1, 2, 3, 4, 5, 6, 7]
  k = 3 # 윈도우 크기
  current_sum = sum(arr[:k]) # 첫 윈도우 합 계산
  max_sum = current_sum
  
  for i in range(k, len(arr)):
    current_sum += arr[i] - arr[i-k] # 윈도우 이동: 맨 앞 요소 빼고 새 요소 추가
    max_sum = max(max_sum, current_sum)
  
  print(f"최대 윈도우 합: {max_sum}") # 최대 윈도우 합: 18 (5+6+7)
  ```
  
  <!----><!----><!---->
  
  <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->