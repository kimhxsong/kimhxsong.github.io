# 📘 알고리즘 기본 개념 정리
- ---
- ### 🔹 Complexity Analysis (복잡도 분석)
- 알고리즘이 얼마나 효율적인지를 분석하는 과정입니다.
- 일반적으로 **시간 복잡도(Time Complexity)** 와 **공간 복잡도(Space Complexity)** 를 평가합니다.
- 알고리즘의 효율성과 비교 우위를 판단하는 데 중요한 지표입니다.
  
  ---
- ### ⏱ Time Complexity (시간 복잡도)
- 알고리즘이 **얼마나 빠르게 실행되는지**를 나타냅니다.
- 입력 크기 `n`에 따른 수행 시간의 증가 양상을 Big-O 표기법으로 표현합니다.
- **빅오 표기법**: O(1), O(log n), O(n), O(n log n), O(n²), O(2ⁿ), O(n!) 등
  
  ---
- ### 💾 Space Complexity (공간 복잡도)
- 알고리즘이 사용하는 **보조 메모리 공간의 양**을 나타냅니다.
- 메모리 효율성을 평가할 수 있으며, 역시 Big-O 표기법으로 나타냅니다.
  
  ---
- ### 📏 Big O Notation (빅오 표기법)
  
  | 복잡도 종류     | 표기           | 설명 |
  |----------------|----------------|------|
  | Constant       | O(1)           | 입력 크기에 관계없이 일정 |
  | Logarithmic    | O(log n)       | 이진 탐색 등 |
  | Linear         | O(n)           | 반복문 한 번 |
  | Log-Linear     | O(n log n)     | 대부분의 정렬 알고리즘 |
  | Quadratic      | O(n²)          | 이중 루프 |
  | Cubic          | O(n³)          | 삼중 루프 |
  | Exponential    | O(2ⁿ)          | 백트래킹 |
  | Factorial      | O(n!)          | 순열 탐색 |
  
  > 💡 일반적으로 인터뷰에서는 **최악의 경우(Worst Case)** 복잡도로 이해함
  
  ---
- ### 🔢 Logarithm (로그)
- 수학적 정의: `log_b(x) = y` 이면 `b^y = x`
- 알고리즘 분석에서는 보통 **밑이 2인 로그**를 사용
- `O(log n)` 시간 복잡도: 입력 크기가 2배가 되어도 연산 횟수는 1만큼 증가
- 예: `O(log n)` 알고리즘은 `n = 1024`일 때 약 10번의 연산만 수행
  
  ---
- ### 📚 Array (배열)
  
  | 연산                      | 시간 복잡도 |
  |--------------------------|--------------|
  | 특정 인덱스 접근         | O(1)         |
  | 특정 인덱스 수정         | O(1)         |
  | 맨 앞에 삽입/삭제        | O(n)         |
  | 중간 삽입/삭제           | O(n)         |
  | 맨 뒤 삽입 (동적 배열)    | amortized O(1) |
  | 맨 뒤 삭제               | O(1)         |
  | 복사                     | O(n)         |
  
  > ✅ Python과 JavaScript에서는 **동적 배열**이 기본
  
  ---
- ### 🔗 Linked List (연결 리스트)
- #### 1. Singly Linked List (단일 연결 리스트)
  
  | 연산                           | 시간 복잡도 |
  |--------------------------------|--------------|
  | head 접근                     | O(1)         |
  | tail 접근                     | O(n)         |
  | 중간 노드 접근                | O(n)         |
  | head 삽입/삭제                | O(1)         |
  | tail 삽입/삭제                | O(n) + O(1)  |
  | 중간 삽입/삭제                | O(n) + O(1)  |
  
  ---
- #### 2. Doubly Linked List (이중 연결 리스트)
- `prev` 포인터가 추가되어 앞/뒤 방향 모두 접근 가능
  
  | 연산                           | 시간 복잡도 |
  |--------------------------------|--------------|
  | head/tail 접근                | O(1)         |
  | 중간 노드 접근                | O(n)         |
  | head/tail 삽입/삭제           | O(1)         |
  | 중간 삽입/삭제                | O(n) + O(1)  |
  
  ---
- #### 3. Circular Linked List (환형 연결 리스트)
- head와 tail이 연결되어 원형 구조를 이룸
- 단일 또는 이중 환형 리스트 모두 가능
  
  ---
- ### 🔑 Hash Table (해시 테이블)
- key → value 매핑을 매우 빠르게 처리하는 자료구조
- 내부적으로 **동적 배열 + 연결 리스트**로 구현됨
- 충돌(collision)을 피하기 위해 해시 함수 사용
  
  | 연산                        | 평균 시간 | 최악 시간 |
  |----------------------------|------------|------------|
  | 삽입 (Insert)              | O(1)      | O(n)       |
  | 삭제 (Remove)              | O(1)      | O(n)       |
  | 탐색 (Lookup)              | O(1)      | O(n)       |
  
  > 💡 충돌이 많을 경우 성능 저하 → 해시 함수 최적화가 중요
  
  ---
- ### 🥞 Stack (스택)
- LIFO 구조 (Last-In, First-Out)
- 동적 배열 또는 단일 연결 리스트로 구현
  
  | 연산                            | 시간 복잡도 |
  |---------------------------------|--------------|
  | push (삽입)                    | O(1)         |
  | pop (삭제)                     | O(1)         |
  | top (조회)                     | O(1)         |
  | 원소 탐색                      | O(n)         |
  
  ---
- ### 📥 Queue (큐)
- FIFO 구조 (First-In, First-Out)
- 보통 **이중 연결 리스트**로 구현
  
  | 연산                            | 시간 복잡도 |
  |---------------------------------|--------------|
  | enqueue (뒤에 삽입)            | O(1)         |
  | dequeue (앞에서 삭제)         | O(1)         |
  | front (앞 원소 조회)          | O(1)         |
  | 원소 탐색                      | O(n)         |
- ### 문자열 (String)
	- 컴퓨터 과학에서 기본적인 데이터 타입 중 하나
	- 메모리에 배열(array) 형태로 저장됨
	- 각 문자는 ASCII와 같은 인코딩을 통해 정수로 매핑됨
	- 대부분의 프로그래밍 언어에서는 불변(immutable)
		- 불변이란 문자열 생성 후 수정이 불가능함을 의미
		- C++은 예외 (std::string은 가변적)
		- 문자열 연결 시 새로운 문자열이 생성되므로 연산 비용이 큼
	- 예시: 불변 문자열에서 발생하는 비효율
		- Python 예제:
			- string = "this is a string"
			- newString = ""
			- for character in string:
				- newString += character
			- 시간 복잡도: O(n²)
				- 매 반복마다 새로운 문자열 생성 → O(n) 연산 x n회
- ### 그래프 (Graph)
	- 노드(vertices)와 간선(edges)으로 구성된 자료구조
	- 실생활 예시:
		- 소셜 네트워크: 사용자(노드), 친구 관계(간선)
		- 도시 지도: 위치(노드), 도로(간선)
	- 사이클 (Cycle)
		- 세 개 이상의 노드가 폐쇄 루프를 이룰 때 발생
		- 상황에 따라 길이 1 또는 2인 루프도 사이클로 인정
	- 비순환 그래프 (Acyclic Graph): 사이클이 없음
	- 순환 그래프 (Cyclic Graph): 하나 이상의 사이클 존재
	- 방향 그래프 (Directed Graph)
		- 간선에 방향성이 있음
		- 예: 항공편 그래프 (A → B만 가능)
	- 무방향 그래프 (Undirected Graph)
		- 간선에 방향성이 없음 (양방향)
		- 예: 친구 관계
	- 연결 그래프 (Connected Graph)
		- 모든 노드 쌍이 경로로 연결됨
		- 방향 그래프의 경우:
			- 강한 연결(strongly connected): u→v, v→u 모두 가능
			- 약한 연결(weakly connected): 방향 무시 시 연결됨
		- 연결되지 않으면 단절 그래프(disconnected)
- ### 트리 (Tree)
	- 연결되고 비순환인 방향 그래프
	- 루트 노드를 기준으로 계층 구조 형성
	- 모든 노드는 하나의 부모만 가짐 (루트 제외)
	- 트리 용어
		- 루트(root): 최상위 노드
		- 리프(leaf): 자식이 없는 노드
		- 가지(branch): 루트에서 리프까지의 경로
		- 높이(height): 루트에서 가장 깊은 리프까지 거리
		- 깊이(depth): 노드가 루트에서 얼마나 떨어져 있는지
	- 이진 트리 (Binary Tree)
		- 각 노드가 최대 2개의 자식을 가짐
	- K진 트리 (K-ary Tree)
		- 각 노드가 최대 K개의 자식을 가짐
	- 완전 이진 트리 (Perfect Binary Tree)
		- 모든 내부 노드가 자식 2개
		- 모든 리프 노드가 동일한 깊이에 존재
	- 완전 이진 트리 (Complete Binary Tree)
		- 마지막 레벨을 제외하고는 자식 2개
		- 마지막 레벨은 왼쪽부터 채워짐
	- 포화 이진 트리 (Full Binary Tree)
		- 모든 노드가 0개 또는 2개의 자식만 가짐
	- 균형 이진 트리 (Balanced Binary Tree)
		- 좌우 서브트리의 높이 차가 1 이하
		- 대부분의 탐색, 삽입, 삭제가 O(log n) 시간